use directory::microstatusentry::{MicroStatusEntry};

use std::net::{Ipv4Addr};
use time::{strptime, Tm};

NL = "\n"
SP = " "

dot = "."
hyphen = "-"
colon = ":"
equal = "="
one = "1"

lowercase
    = [a-z]

uppercase
    = [A-Z]

digit
    = [0-9]

letters_and_digits
    = (uppercase/lowercase/digit)+

base64
    = (letters_and_digits/[+/])+

/*
 * Date/time
 */

date_time_seq
    = date_seq SP time_seq

date_seq
    = year hyphen month hyphen day

time_seq
    = hour colon minute colon second

year
    = digit{4}

month
    = digit{2}

day
    = digit{2}

hour
    = digit{2}

minute
    = digit{2}

second
    = digit{2}

/*
 * IP Addresses
 */

ipv4_addr
    = ((ipv4_octet "."){3} ipv4_octet)

ipv4_octet
    = digit{1,3}

/*
 * Recognized Flags
 */

known_flags
    = (authority_flag   /
       badexit_flag     /
       exit_flag        /
       fast_flag        /
       guard_flag       /
       hsdir_flag       /
       named_flag       /
       stable_flag      /
       running_flag     /
       valid_flag       /
       v2dir_flag)

authority_flag
    = "Authority"

badexit_flag
    = "BadExit"

exit_flag
    = "Exit"

fast_flag
    = "Fast"

guard_flag
    = "Guard"

hsdir_flag
    = "HSDir"
    
named_flag
    = "Named"

stable_flag
    = "Stable"

running_flag
    = "Running"

unnamed_flag
    = "Unnamed"

valid_flag
    = "Valid"

v2dir_flag
    = "V2Dir"


/*
 * Micro Status Entry
 */

#[export]
micro_status_entry -> MicroStatusEntry
   = r:r_line_micro m:m_line_micro s:s_line_micro v:v_line_micro? w:w_line_micro? {
        MicroStatusEntry {
            nickname:       r.0,
            identity:       r.1,
            publication:    r.2,
            ip:             r.3,
            orport:         r.4,
            dirport:        r.5,
            digest:         m,
        }
    }

/*
 * 'r' line components
 */
r_line_micro -> (String, String, Tm, Ipv4Addr, u32, u32)
    = r SP n:nickname SP i:identity SP p:publication SP ip:IP SP op:ORPort SP dp:DirPort NL {
        
        (n, i, p, ip, op, dp)
    }

r
    = "r"

nickname -> String
    = letters_and_digits { match_str.to_string() }

identity -> String
    = base64+ { match_str.to_string() }

publication -> Tm
    = date_time_seq { strptime(match_str, "%Y-%m-%d %H:%M:%S").unwrap() }

IP -> Ipv4Addr
    = ipv4_addr { 
        let addr: Ipv4Addr = match_str.parse().unwrap();
        addr
    }

ORPort -> u32
    = digit+ { match_str.parse().unwrap() }

DirPort -> u32
    = digit+ { match_str.parse().unwrap() }

/*
 * 'm' line components
 */

m_line_micro -> String
    = m SP d:digest NL { d }

m
    = "m"

digest -> String
    = base64+ { match_str.to_string() }

/*
 * 's' line components
 */

s
    = "s"

s_line_micro
    = s SP Flags NL

Flags
    = (known_flags/SP)*

/*
 * 'v' line components
 */

v
    = "v"

v_line_micro -> String
    = v SP v:version NL { v.to_string() }

version -> &'input str
    = (uppercase/lowercase/digit/SP/dot/hyphen)* { match_str }

/*
 * 'w' line components
 */

w
    = "w"

//w_line_micro
//    = w SP Bandwidth SP Unmeasured NL
w_line_micro
    = w SP Bandwidth NL

Bandwidth
    = bandwidth_kword equal digit+

bandwidth_kword
    = "Bandwidth"

/*
Unmeasured
    = unmeasured_kword equal one
*/
