use directory::microstatus::{Flag, Entry};

use std::net::{Ipv4Addr};
use time::{strptime, Tm};

/********************
 *                  *
 * Building blocks. *
 *                  *
 ********************/
/*
 * Basics
 */
NL          = "\n"
SP          = " "
dot         = "."
hyphen      = "-"
minus       = "-"
comma       = ","
colon       = ":"
equal       = "="
underscore  = "_"
one         = "1"
lowercase   = [a-z]
uppercase   = [A-Z]
letters     = [a-zA-Z]
digit       = [0-9]
alphanum    = (letters/digit)
base64      = (alphanum/[+/])
/*
 * Date/time
 */
year            = digit{4}
month           = digit{2}
day             = digit{2}
hour            = digit{2}
minute          = digit{2}
second          = digit{2}
time_seq        = hour colon minute colon second
date_seq        = year hyphen month hyphen day
date_time_seq   = date_seq SP time_seq
/*
 * IP Addresses
 */
ipv4_octet  = digit{1,3}
ipv4_addr   = ((ipv4_octet "."){3} ipv4_octet)
/*
 * Recognized Flags
 */
authority_flag  = "Authority"
badexit_flag    = "BadExit"
exit_flag       = "Exit"
fast_flag       = "Fast"
guard_flag      = "Guard"
hsdir_flag      = "HSDir"
named_flag      = "Named"
stable_flag     = "Stable"
running_flag    = "Running"
unnamed_flag    = "Unnamed"
valid_flag      = "Valid"
v2dir_flag      = "V2Dir"
known_flags
    = (authority_flag   /
       badexit_flag     /
       exit_flag        /
       fast_flag        /
       guard_flag       /
       hsdir_flag       /
       named_flag       /
       stable_flag      /
       running_flag     /
       valid_flag       /
       v2dir_flag)

/********************
 *                  *
 * Micro consensus. *
 *                  *
 ********************/
/*
 * Preamble
 */
//micro_status_preamble
//    = p_version_line p_vote_status_line p_method_line p_valid_after_line p_fresh_until_line p_valid_until_line p_voting_delay_line p_client_versions_line p_server_versions_line p_known_flags_line p_params_line
#[export]
micro_status_preamble
    = p_version_line
      p_vote_status_line
      p_method_line
      p_valid_after_line
      p_fresh_until_line
      p_valid_until_line
      p_voting_delay_line
      p_client_versions_line
      p_server_versions_line
      p_known_flags_line
      p_params_line

// consensus version line
p_version_line
    = ns_version_kword SP ns_version SP microdesc NL

ns_version_kword
    = "network-status-version"

ns_version
    = digit+

microdesc
    = "microdesc"
// vote-status line
p_vote_status_line
    = vote_status_kword SP consensus NL

vote_status_kword
    = "vote-status"

consensus
    = "consensus"
// method line
p_method_line
    = ns_method_kword SP ns_method NL

ns_method_kword
    = "consensus-method"

ns_method
    = digit+
// valid-after line
p_valid_after_line
    = valid_after_kword SP valid_after_date_time NL

valid_after_kword
    = "valid-after"

valid_after_date_time
    = date_time_seq
//    = date_time_seq { strptime(match_str, "%Y-%m-%d %H:%M:%S").unwrap() }
// fresh-until line
p_fresh_until_line
    = fresh_until_kword SP fresh_until_date_time NL

fresh_until_kword
    = "fresh-until"

fresh_until_date_time
    = date_time_seq
// valid-until line
p_valid_until_line
    = valid_until_kword SP valid_until_date_time NL

valid_until_kword
    = "valid-until"

valid_until_date_time
    = date_time_seq
// voting-delay line
p_voting_delay_line
    = voting_delay_kword SP vote_seconds SP dist_seconds NL

voting_delay_kword
    = "voting-delay"

vote_seconds
    = digit+

dist_seconds
    = digit+
// client-versions line
p_client_versions_line
    = client_versions_kword SP client_versions_str NL

client_versions_kword
    = "client-versions"

// TODO: make this more strict based on version-spec?
client_versions_str
    = single_version_str ++ comma

single_version_str
    = (digit/"."/hyphen/lowercase)+
// server-versions line
p_server_versions_line
    = server_versions_kword SP server_versions_str NL

server_versions_kword
    = "server-versions"

// TODO: make this more strict based on version-spec?
server_versions_str
    = single_version_str ++ comma
// known-flags line
p_known_flags_line
    = known_flags_kword SP known_flags_list NL

known_flags_kword
    = "known-flags"

known_flags_list
    = flag_str ++ SP

flag_str
    = (letters/digit)+
// params line
p_params_line
    = params_kword SP params_list NL

params_kword
    = "params"

params_list
    = param_key_equal_value ++ SP

param_key_equal_value
    = param_key equal param_value

param_key
    = (alphanum/underscore)+

param_value
    = minus? digit+

/*
 * Micro Status Entry
 */

#[export]
micro_status_entry -> Entry
   = r:r_line_micro
     m:m_line_micro
     s:s_line_micro
     v:v_line_micro?
     w:w_line_micro? {

        let wv: (Option<u32>, Option<bool>) = match w {
            Some(v) => (Some(v.0), v.1),
            None    => (None, None),
        };

        Entry {
            nickname:       r.0,
            identity:       r.1,
            publication:    r.2,
            ip:             r.3,
            orport:         r.4,
            dirport:        r.5,
            digest:         m,
            flags:          s,
            version:        v,
            bandwidth:      wv.0,
            unmeasured:     wv.1,
        }
    }

/*
 * 'r' line components
 */
r_line_micro -> (String, String, Tm, Ipv4Addr, u32, u32)
    = r SP
    n:nickname SP
    i:identity SP
    p:publication SP
    ip:IP SP
    op:ORPort SP
    dp:DirPort NL {
        
        (n, i, p, ip, op, dp)
    }

r
    = "r"

nickname -> String
    = alphanum+ { match_str.to_string() }

identity -> String
    = base64+ { match_str.to_string() }

publication -> Tm
    = date_time_seq { strptime(match_str, "%Y-%m-%d %H:%M:%S").unwrap() }

IP -> Ipv4Addr
    = ipv4_addr { 
        let addr: Ipv4Addr = match_str.parse().unwrap();
        addr
    }

ORPort -> u32
    = digit+ { match_str.parse().unwrap() }

DirPort -> u32
    = digit+ { match_str.parse().unwrap() }

/*
 * 'm' line components
 */

m_line_micro -> String
    = m SP d:digest NL { d }

m
    = "m"

digest -> String
    = base64+ { match_str.to_string() }

/*
 * 's' line components
 */

s
    = "s"

s_line_micro -> Vec<Flag>
    = s SP f:Flags NL {
        let all = f.split(" ");
        let cap = match all.size_hint().1 {
            Some(v) => v,
            None => 0,
        };
        let mut v: Vec<Flag> = Vec::with_capacity(cap);

        for i in all {
            match i {
                "Authority" => v.push(Flag::Authority),
                "BadExit" => v.push(Flag::BadExit),
                "Exit" => v.push(Flag::Exit),
                "Fast" => v.push(Flag::Fast),
                "Guard" => v.push(Flag::Guard),
                "HSDir" => v.push(Flag::HSDir),
                "Named" => v.push(Flag::Named),
                "Stable" => v.push(Flag::Stable),
                "Running" => v.push(Flag::Running),
                "Valid" => v.push(Flag::Valid),
                "V2Dir" => v.push(Flag::V2Dir),
                _ => unreachable!("Unrecognized flag."),
            }
        }

        v
    }

Flags -> &'input str
    = (known_flags/SP)* { match_str }

/*
 * 'v' line components
 */

v
    = "v"

v_line_micro -> String
    = v SP v:version NL { v.to_string() }

version -> &'input str
    = (uppercase/lowercase/digit/SP/dot/hyphen)* { match_str }

/*
 * 'w' line components
 */

w
    = "w"

w_line_micro -> (u32, Option<bool>)
    = w SP b:Bandwidth SP? u:Unmeasured? NL { (b, u) }

Bandwidth -> u32
    = bandwidth_kword equal b:bval { b }

bandwidth_kword
    = "Bandwidth"

bval -> u32
    = digit+ { match_str.parse::<u32>().unwrap() }

Unmeasured -> bool
    = unmeasured_kword equal one { true }

unmeasured_kword
    = "Unmeasured"
