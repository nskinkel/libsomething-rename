use directory::microstatus::{Flag, Entry};

use std::net::{Ipv4Addr};
use time::{strptime, Tm};

/********************
 *                  *
 * Building blocks. *
 *                  *
 ********************/
/*
 * Basics
 */
NL          = "\n"
SP          = " "
dot         = "."
hyphen      = "-"
colon       = ":"
equal       = "="
one         = "1"
lowercase   = [a-z]
uppercase   = [A-Z]
digit       = [0-9]
alphanum    = (uppercase/lowercase/digit)+
base64      = (alphanum/[+/])+
/*
 * Date/time
 */
year            = digit{4}
month           = digit{2}
day             = digit{2}
hour            = digit{2}
minute          = digit{2}
second          = digit{2}
time_seq        = hour colon minute colon second
date_seq        = year hyphen month hyphen day
date_time_seq   = date_seq SP time_seq
/*
 * IP Addresses
 */
ipv4_octet  = digit{1,3}
ipv4_addr   = ((ipv4_octet "."){3} ipv4_octet)
/*
 * Recognized Flags
 */
authority_flag  = "Authority"
badexit_flag    = "BadExit"
exit_flag       = "Exit"
fast_flag       = "Fast"
guard_flag      = "Guard"
hsdir_flag      = "HSDir"
named_flag      = "Named"
stable_flag     = "Stable"
running_flag    = "Running"
unnamed_flag    = "Unnamed"
valid_flag      = "Valid"
v2dir_flag      = "V2Dir"
known_flags
    = (authority_flag   /
       badexit_flag     /
       exit_flag        /
       fast_flag        /
       guard_flag       /
       hsdir_flag       /
       named_flag       /
       stable_flag      /
       running_flag     /
       valid_flag       /
       v2dir_flag)

/********************
 *                  *
 * Micro consensus. *
 *                  *
 ********************/
/*
 * Preamble
 */
//micro_status_preamble
//    = p_version_line p_vote_status_line p_method_line p_published_line p_valid_after_line p_fresh_until_line p_valid_until_line p_voting_delay_line p_client_versions_line p_server_versions_line p_known_flags_line p_params_line
#[export]
micro_status_preamble
    = p_version_line

p_version_line
    = ns_version_kword SP ns_version SP microdesc NL

ns_version_kword
    = "network-status-version"

ns_version
    = digit+

microdesc
    = "microdesc"


/*
 * Micro Status Entry
 */

#[export]
micro_status_entry -> Entry
   = r:r_line_micro
     m:m_line_micro
     s:s_line_micro
     v:v_line_micro?
     w:w_line_micro? {

        let wv: (Option<u32>, Option<bool>) = match w {
            Some(v) => (Some(v.0), v.1),
            None    => (None, None),
        };

        Entry {
            nickname:       r.0,
            identity:       r.1,
            publication:    r.2,
            ip:             r.3,
            orport:         r.4,
            dirport:        r.5,
            digest:         m,
            flags:          s,
            version:        v,
            bandwidth:      wv.0,
            unmeasured:     wv.1,
        }
    }

/*
 * 'r' line components
 */
r_line_micro -> (String, String, Tm, Ipv4Addr, u32, u32)
    = r SP
    n:nickname SP
    i:identity SP
    p:publication SP
    ip:IP SP
    op:ORPort SP
    dp:DirPort NL {
        
        (n, i, p, ip, op, dp)
    }

r
    = "r"

nickname -> String
    = alphanum { match_str.to_string() }

identity -> String
    = base64+ { match_str.to_string() }

publication -> Tm
    = date_time_seq { strptime(match_str, "%Y-%m-%d %H:%M:%S").unwrap() }

IP -> Ipv4Addr
    = ipv4_addr { 
        let addr: Ipv4Addr = match_str.parse().unwrap();
        addr
    }

ORPort -> u32
    = digit+ { match_str.parse().unwrap() }

DirPort -> u32
    = digit+ { match_str.parse().unwrap() }

/*
 * 'm' line components
 */

m_line_micro -> String
    = m SP d:digest NL { d }

m
    = "m"

digest -> String
    = base64+ { match_str.to_string() }

/*
 * 's' line components
 */

s
    = "s"

s_line_micro -> Vec<Flag>
    = s SP f:Flags NL {
        let all = f.split(" ");
        let cap = match all.size_hint().1 {
            Some(v) => v,
            None => 0,
        };
        let mut v: Vec<Flag> = Vec::with_capacity(cap);

        for i in all {
            match i {
                "Authority" => v.push(Flag::Authority),
                "BadExit" => v.push(Flag::BadExit),
                "Exit" => v.push(Flag::Exit),
                "Fast" => v.push(Flag::Fast),
                "Guard" => v.push(Flag::Guard),
                "HSDir" => v.push(Flag::HSDir),
                "Named" => v.push(Flag::Named),
                "Stable" => v.push(Flag::Stable),
                "Running" => v.push(Flag::Running),
                "Valid" => v.push(Flag::Valid),
                "V2Dir" => v.push(Flag::V2Dir),
                _ => unreachable!("Unrecognized flag."),
            }
        }

        v
    }

Flags -> &'input str
    = (known_flags/SP)* { match_str }

/*
 * 'v' line components
 */

v
    = "v"

v_line_micro -> String
    = v SP v:version NL { v.to_string() }

version -> &'input str
    = (uppercase/lowercase/digit/SP/dot/hyphen)* { match_str }

/*
 * 'w' line components
 */

w
    = "w"

w_line_micro -> (u32, Option<bool>)
    = w SP b:Bandwidth SP? u:Unmeasured? NL { (b, u) }

Bandwidth -> u32
    = bandwidth_kword equal b:bval { b }

bandwidth_kword
    = "Bandwidth"

bval -> u32
    = digit+ { match_str.parse::<u32>().unwrap() }

Unmeasured -> bool
    = unmeasured_kword equal one { true }

unmeasured_kword
    = "Unmeasured"
